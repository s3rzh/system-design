Разделение системы (веб-сервер) на веб-уровень (веб-сервер) и уровень данных (БД) позволяет *масштабировать* эти компоненты независимо друг от друга.

**Реляционные БД** (MySQL, Oracle, PostgreSQL и т. д.) предоставляют и хранят данные в таблицах и строках. С помощью SQL можно выполнять операции объединения между различными таблицами базы данных.

**Нереляционные БД** также называют *NoSQL* (CouchDB, Neo4j, Cassandra, HBase, Amazon DynamoDB и т. д.). Эти базы данных делятся на четыре категории: хранилища «ключ–значение», графовые, столбцовые и документные. Нереляционные БД обычно неподдерживают операции соединения. Нереляционные БД могут быть подходящим решением, если:
  - ваше приложение нуждается в крайне низкой латентности (**Latency** - это время ожидания, которое требуется на доставку пакета данных от источника к пункту назначения.);
  - ваши данные не структурированы или не имеют никаких реляционных связей;
  - вам нужно лишь сериализовать и десериализовать свои данные(JSON, XML, YAML и т. д.). *Сериализация и десериализация* - это процессы преобразования данных из одной формы в другую с целью сохранения или передачи информации.;
  - вам нужно хранить огромные объемы данных.

**Вертикальное масштабирование**, известное как наращивание, — это процесс повышения мощности ваших серверов (процессоров, памяти оперативной или дисковой и т. д.). Вертикальное масштабирование отлично подходит для задач с небольшим трафиком. Его главным преимуществом является простота (добавить несколько планок RAM просто). Но есть ряд серьезных ограничений:
  - Вертикальное масштабирование имеет жесткий лимит. Ресурсы отдельно взятого сервера нельзя увеличивать бесконечно.
  - Вертикальное масштабирование не предусматривает отказоустойчивость и резервирование избыточных ресурсов. Если один из серверов выйдет из строя, веб-сайт/приложение станет полностью недоступным.
    
**Горизонтальное масштабирование**, которое еще называют расширением, заключается в добавлении новых серверов в пул ресурсов. Лучше подходит для крупномасштабных приложений.

**Балансировщик нагрузки** равномерно распределяет входящий трафик между веб-серверами (чтобы один сервер не вышел из строя после внезамно возросшей нагрузки от большого кол-ва пользователей). Те запросы от пользователей идут на IP-адрес балансировщика нагрузки (который был получен от DSN сервера). По соображениям безопасности для взаимодействия между серверами используются внутренние IP-адреса. Внутренний IP доступен только для серверов из той же *сети*, но не виден из интернета. Балансировщик нагрузки взаимодействует с веб-серверами с помощью внутренних IP-адресов. За счет добавления балансировщика нагрузки и второго сервера нам удается решить проблему с отсутствием отказоустойчивости и улучшить доступность веб-уровня. Т.е.:
 - Если сервер 1 выходит из строя, весь трафик перенаправляется к серверу 2. Благодаря этому веб-сайт остается доступным. Чтобы сбалансировать нагрузку, мы добавим в пул серверов новый исправный веб-сервер.
 - Если посещаемость веб-сайта стремительно растет и для обслуживания трафика не хватает двух серверов, балансировщик нагрузки может изящно справиться с этой проблемой. Для этого достаточно расширить пул серверов, и балансировщик начнет автоматически
передавать запросы новым веб-серверам.

**Репликая** - те создание копии БД, решает проблему отказоустойчивости и резервирования для уровня БД. Репликация баз данных обычно используется в режиме "ведущий–ведомый", где роль ведущего сервера играет оригинал (master), а его копии являются ведомыми (slave). Ведущая база данных обычно поддерживает только операции записи. Ведомые БД получают от ведущей копии ее содержимого и поддерживают только операции чтения (если ведомая БД только одна - то после её падения операции чтения перенаправятся на ведущую, если же более одной - то перенаправятся на остальным ведомые). Если ведущая база данных выйдет из строя, ее место (временно) займет одна из ведомых.
Все команды для модификации данных, такие как *вставка*, *удаление* или *обновление*, должны направляться ведущей базе данных. В большинстве приложений чтение происходит намного чаще, чем запись, поэтому ведомых БД обычно больше, чем ведущих. Преимущества репликации базы данных:
  - Повышенная производительность. В модели «ведущий–ведомый» все операции записи и обновления происходят на ведущих узлах, а операции чтения распределяются между ведомыми. Это улучшает производительность, увеличивая количество запросов, которые можно обрабатывать параллельно.
  - Надежность. Если один из ваших серверов с базой данных сломается из-за стихийного бедствия, такого как тайфун или землетрясение, данные не будут утеряны. Вам не нужно беспокоиться о потере данных, так как они реплицируются по разным местам.
  - Высокая доступность. За счет репликации данных по разным местам ваш веб-сайт будет продолжать работать, даже если одна из БД вый­дет из строя, поскольку у вас по-прежнему будет доступ к данным, размещенным на другом сервере.

**Кэш** — это участок памяти (оперативной, те быстрой), в который временно записываются результаты ресурсоемких ответов или данных, к которым часто обращаются. Это позволяет ускорить обслуживание последующих запросов (тк многократное обращение к БД существенно влияет на производительность в худшую сторону). Преимущество отдельного кэша - это возможность масштабировать его. Если данные есть в кэше, читаем их из кэша, если данных нет в кэше - читаем из БД и сохраняем их в кэш. Эта стратегия называется *кэшем сквозного чтения*.

Некоторые аспекты использования кэша:
  - Определитесь с тем, когда будет использоваться кэш. Это лучше делать в ситуациях, когда чтение данных происходит часто, а изменение — редко. Поскольку кэшированные данные хранятся в энергозависимой памяти, сервер кеширования не подходит для постоянного хранения. Например, если он перезапустится, все данные, хранившиеся в памяти, будут утрачены. В связи с этим данные необходимо записывать в постоянные хранилища.
  - Выбор срока действия. Рекомендуется реализовать механизм, ограничивающий срок действия кэша. Просроченные данные немедленно удаляются. Если такого механизма нет, данные будут храниться в памяти постоянно. Срок действия лучше не делать слишком коротким, иначе система будет слишком часто обновлять данные, загружая их из БД. С другой стороны, из-за слишком длинного срока действия данные могут оказаться неактуальными.
  - Согласованность. Это подразумевает синхронизацию данных в хранилище и кэше. Несогласованность может возникнуть из-за того, что операции изменения данных в хранилище и кэше выполняются не за одну транзакцию. При масштабировании системы в пределах нескольких регионов может быть непросто поддерживать согласованность.
  - Предотвращение сбоев. Наличие лишь одного сервера кэширования может оказаться потенциальной единой точкой отказа (single point of failure, SPOF), которая, согласно английской Википедии, имеет следующее определение: «Единая точка отказа — это компонент, выход из строя которого приводит к прекращению работы всей системы». В связи с этим, чтобы избежать SPOF, рекомендуется использовать несколько серверов кэширования, размещенных в разных центрах обработки данных (ЦОД). А еще можно выделить какой-нибудь дополнительный объем памяти: это создаст буфер на случай, если память начнет использоваться более активно. 
  - Политика вытеснения. Когда кэш полностью заполнен, любой запрос на добавление новых элементов может привести к удалению существующих. Это называют вытеснением кэша. Самой по­пулярной политикой считается вытеснение давно неиспользуемых данных (least-recently-used, LRU). Для разных ситуаций могут также подойти вытеснение наименее часто используемых данных (least-frequently-used, LFU) или метод «первым пришел, первым ушел» (FIFO, first-in-first-out).

**CDN** — это сеть географически распределенных серверов, которая используется для доставки статического содержимого. Серверы CDN кэшируют такие статические файлы, как изображения, видео, CSS, JavaScript и т. д. Принцип работы - когда пользователь посещает веб-сайт, ближайший к нему сервер CDN доставляет статическое содержимое (файл), но если в кэше сервера CDN нет запрашиваемого файла он запрашивает этот файл
из оригинального источника, например веб-сервера или онлайн-хранилища вроде Amazon S3 (или др. S3-подобного). Источник (веб-сервера или онлайн-хранилища) возвращает серверу CDN файл вместе с дополнительным HTTP-заголовком TTL (Time-to-Live — «время жизни»), который определяет, как долго изображение будет находиться в кэше. CDN кэширует файл и возвращает его пользователю. Оно остается в кэше CDN, пока не истечет срок TTL. При повтороном обращени к файлу - если срок TTL еще не истек, изображение возвращается из кэша.

Нюансы использования CDN:
  - Стоимость. Серверы CDN предоставляются сторонними компаниями, а перемещение данных в CDN и из CDN стоит денег. Кэширование нечасто используемых ресурсов не даст существенных преимуществ, поэтому из CDN их лучше убрать.
  - Подбор подходящего срока годности кэша. Для содержимого, которое зависит от времени, необходимо предусмотреть срок годности кэша. Он должен быть не слишком длинным, но и не слишком коротким. В первом случае содержимое может потерять свою актуальность, а во втором — привести к повторной перезагрузке содержимого с исходных серверов в CDN.
  - Возможность сбоев. Вы должны подумать о том, как ваши веб-сайты/приложения будут справляться с недоступностью CDN. Если CDN временно выходит из строя, у клиента должна быть возможность обнаружить эту проблему и запросить ресурсы из исходного источника.
  - Аннулирование файлов. Файлы можно удалять из CDN до истечения их срока годности одним из следующих способов:
    - аннулировать объект CDN с помощью API-интерфейсов, предоставляемых поставщиками CDN;
    - использовать версионирование, чтобы возвращать разные версии объектов. Для этого к URL-адресу можно добавить параметр с номером версии. Например, версия 2 может быть представлена строкой запроса: image.png?v=2.

Для *горизонтального масштабирования* веб-уровня (веб-сервиса, веб-сервер). Для этого нужно вынести из него состояние, те stateless (например, информацию о пользовательских сеансах).  Данные сеансов рекомендуется записывать в постоянные хранилища, такие как реляционные БД или NoSQL. Каждый веб-сервер в кластере может запросить состояние из БД. Отсутствие состояния делает систему более простой, надежной и масштабируемой.

От того, хранит сервер состояние или нет, зависит, будет ли он «помнить» данные клиента (состояние) между разными запросами. Чтобы пользователь попадал именно на тот сервер, на котором хранятся его данные сеанса - балансировщик нагрузки должен всегда перенапралвять его на один и тот же сервер (бу алансировщиков нагрузки для этого предусмотрены *липкие сеансы*) иначе пользователь будет не аутентифицирован (те распознан, тк данных о нём на этом сервере нет).

Подход *липкие сеансы*  увеличивает накладные расходы. Из-за него добавление и удаление серверов дается с трудом. Также возникают проблемы, если сервер выходит из строя.

***Автомасштабирование** означает, что добавление и удаление веб-серверов происходит автоматически в зависимости от объемов трафика за счет добавления и удаления серверов с учетом нагрузки.

**ЦЕНТРЫ ОБРАБОТКИ ДАННЫХ** (ЦОД) - используются для улучшения *доступности* и *UX*, их должно быть несколько. Те с помощью GeoDNS направляются к ближайшему центру обработки данных. В случае любого серьезного нарушения работы одного из центров обработки данных мы перенаправляем весь трафик к исправному ЦОД.

**UX** расшифровывается как *user experience* ― «пользовательский опыт». Это то, каким образом пользователь взаимодействует с интерфейсом и насколько сайт или приложение для него удобны.

**GeoDNS** (система географических доменных имен) - это процесс распределения трафика на основе местоположения запросов. Его также называют *директором трафика* или *директором глобального трафика*. Используя сервис GeoDNS, вы можете эффективно оптимизировать трафик к доменам за счет использования географической маршрутизации.

Для реализации архитектуры с несколькими центрами обработки данных необходимо решить несколько технических вопросов:
  - Перенаправление трафика. Необходимы эффективные инструменты для направления трафика к подходящему ЦОД. GeoDNS позволяет выбирать центр обработки данных, который находится ближе всего к пользователю.
  - Синхронизация данных. Пользователи могут работать с разными локальными базами данных и кэшами в зависимости от региона. В случае сбоя трафик может быть перенаправлен к ЦОД, в котором нет запрашиваемых данных. Распространенным решением является репликация данных между несколькими ЦОД.
  - Тесты и развертывание. В конфигурации с несколькими ЦОД тестирование веб-сайта/приложения необходимо проводить в разных местах. Автоматические средства развертывания незаменимы в поддержании согласованности всех ЦОД.

Чтобы еще сильнее улучшить масштабируемость системы, ее следует разделить на компоненты; это позволит масштабировать их независимо друг от друга, а для взаимодействия этих компонентов в распределенных системах хорошо подходят очереди сообщений.

**Очередь сообщений** — это устойчивый компонент, который загружается в память и поддерживает асинхронное взаимодействие. Он служит буфером и распределяет асинхронные запросы. Очередь сообщений имеет
простую базовую архитектуру. Сервисы ввода, так называемые производители/издатели, создают сообщения и публикуют их в очереди. Другие сервисы или серверы, которые называют потребителями/подписчиками,
подключаются к очереди, читаю сообщения и выполняют действия, определенные в этих сообщениях.





















